#!/usr/bin/python3
#
# Copyright 2020 Delphix
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import curses
import curses.ascii
import curses.textpad
import sys
import os
import logging
import time
import subprocess

STATUS_HEADER = "STATUS\t\t\tSERVICE\t\t\t"
LAYOUT_STR = "Keyboard layout (press 9 to change):"
CONSOLE_STR = "Press any other key for console access."
KEY_LAYOUT_SELECT_STR = "Select a keyboard layout by number [1-%d]:"

log_file = "/tmp/dpx_startup_screen.log"
logo = "Delphix Engine Version "

website = "www.delphix.com"

WIN_LEN = 0
WIN_HT = 0

def get_svcs():
    cmd = ['systemctl', 'show', '-p',  'Wants', 'delphix.target']
    cp = subprocess.run(cmd, stdout=subprocess.PIPE, universal_newlines=True)
    return cp.stdout.split("=", 1)[1].split()

def run_svcs(options=None):
    '''
    Run the command to retrieve the status of all the services. The options
    argument can be used to obtain additional output from the 'systemctl'
    command. By default we only obtain the 'ActiveState' of the services.
    '''

    fields = 'ActiveState'
    cmd = ['systemctl', 'show', '--value', '-p']
    if options:
        fields += ',' + options
    cmd.append(fields)
    for svc in get_svcs():
        cmd.append(svc)
    cp = subprocess.run(cmd, stdout=subprocess.PIPE, universal_newlines=True)
    return cp.stdout

def get_keyboard_layout():
    cmd = ['localectl', 'status']
    cp = subprocess.run(cmd, stdout=subprocess.PIPE, universal_newlines=True)
    output = cp.stdout.split()
    return output[output.index("Layout:") + 1]

def set_keyboard_layout(layout):
    cmd = ['localectl', 'set-x11-keymap', layout, 'pc105']
    cp = subprocess.run(cmd, shell=False)
    return subprocess.run('setupcon', shell=False)

def get_valid_keyboard_layouts():
    cmd = ['localectl', '--no-pager', 'list-x11-keymap-layouts']
    cp = subprocess.run(cmd, stdout=subprocess.PIPE, universal_newlines=True)
    return cp.stdout.splitlines()

def load_header(stdscr):
    global logo

    cmd = ['/opt/delphix/server/bin/get_appliance_version']
    cp = subprocess.run(cmd, stdout=subprocess.PIPE, universal_newlines=True)
    version = cp.stdout.split('-', 1)[0]

    stdscr.clear()
    stdscr.addstr(1, 2, logo + str(version), curses.A_BOLD)
    stdscr.addstr(1, WIN_LEN - len(website) - 2, website,
                  curses.A_BOLD)

    win = stdscr.subwin(WIN_HT - 4, WIN_LEN - 4, 3, 2)
    win.bkgd(' ', curses.color_pair(2))
    win.box()
    return win

def is_server_down():
    '''
    Determine if the server is down by looking at the state of all the
    services. If any service is 'failed' then we declare the server down.
    '''
    out = run_svcs()
    for i in out.splitlines(False):
        #
        # Skip any empty lines
        #
        if not i.strip():
            continue

        if i.strip() == "failed":
            return True
    return False

def is_server_up():
    '''
    Determine if all the services are 'active' or 'inactive'. Inactive
    is considered up since the service may not be enabled.
    '''
    out = run_svcs().rstrip("\n")
    for i in out.splitlines(True):
        #
        # Skip any empty lines
        #
        if not i.strip():
            continue

        if i.strip() != "active" and i.strip() != "inactive":
            return False
    return True

#
# Sets the common variables.
#
def set_common_variables(stdscr):
    global WIN_LEN
    global WIN_HT

    if curses.has_colors():
        curses.start_color()
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
        curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_BLUE)
        curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_GREEN)
        curses.init_pair(4, curses.COLOR_BLACK, curses.COLOR_YELLOW)
        curses.init_pair(5, curses.COLOR_BLACK, curses.COLOR_RED)
        stdscr.bkgd(' ', curses.color_pair(1))

    (Y, X) = stdscr.getmaxyx()

    WIN_LEN = X
    WIN_HT = Y

def getstatus():
    '''
    Each service returns 2 lines -- one with the description and the
    next line with the state. In addition, a newline separates each
    service.
    '''
    out = run_svcs("Description").splitlines()
    str = ""
    for i in range(0, len(out), 3):
        #
        # Switch the state and description
        #
        str = str + out[i+1] + "\t" + out[i] + "\n"
    return str

def get_network_status():
    '''
    Returns a tuple of (hostname, ipaddr) for the main interface.
    '''

    #
    # We get the primary address based on the default route. The
    # address we use follows the 'src' key in the output.
    #
    cmd = ['ip', 'route', 'show', '0.0.0.0/0']
    cp = subprocess.run(cmd, stdout=subprocess.PIPE, universal_newlines=True)
    output = cp.stdout.split()
    ipaddr = output[output.index("src") + 1]
    hostname = os.uname()[1]
    return (hostname, ipaddr)

def display_status(stdscr, win):
    (Y, X) = win.getmaxyx()

    layout = get_keyboard_layout()

    width = X - 10
    height = Y - 8
    status = 0

    x = int((X - width) / 2) + 2
    y = (Y - height - 1)

    win.clear()
    win.box()
    win.addstr(1, 2, LAYOUT_STR, curses.A_BOLD)
    win.addstr(1, 3 + len(LAYOUT_STR), layout)
    win.addstr(2, 2, CONSOLE_STR, curses.A_BOLD)

    win.refresh()
    stdscr.refresh()

    netwin = win.subwin(2, width, Y, 5)
    statuswin = win.subwin(height, width, y, x)

    while True:
        status += 1

        if is_server_up() == True:
            statuswin.bkgd(' ', curses.color_pair(3))
        elif is_server_down() == True:
            statuswin.bkgd(' ', curses.color_pair(5))
        else:
            statuswin.bkgd(' ', curses.color_pair(4))

        sys.stdout.flush()
        sys.stderr.flush()

        (hostname, ipaddr) = get_network_status()
        netwin.clear()
        netwin.addstr(0, 0, "Host: http://" + hostname + "/", curses.A_BOLD)
        netwin.addstr(1, 0, "IP: " + ipaddr, curses.A_BOLD)
        netwin.noutrefresh()

        # We get status every 10 secs
        strout = getstatus()

        if (status % 10) == 0:
            status = 0
            statuswin.clear()
        statuswin.box()

        START = 2
        statuswin.addstr(START, 5, STATUS_HEADER, curses.A_STANDOUT)
        START += 1
        statuswin.hline(START, 5, curses.ACS_HLINE, 45)
        for i in strout.split("\n"):
            START += 1
            statuswin.addstr(START, 2, " " * (width - 3), curses.A_BOLD)
            statuswin.addstr(START, 5, str(i), curses.A_STANDOUT)
        statuswin.noutrefresh()

        curses.doupdate()

        # Read any user keystroke if present. We wait for any keystroke
        # for 10 secs here
        curses.halfdelay(100)
        keypress = stdscr.getch()
        # -1 means timeout, anything else is a key press
        if -1 != keypress:
            return keypress

def display_keyboard_layout_selection(stdscr, win):
    (Y, X) = win.getmaxyx()

    win.clear()
    win.box()

    layouts = get_valid_keyboard_layouts()

    x = 2
    y = 1
    width = -1
    for count in range(len(layouts)):
        layoutstr = "{0:>2}) {1}".format(count + 1, layouts[count])
        win.addstr(y, x, layoutstr)
        y += 1
        width = max(width, len(layoutstr))
        if y >= Y - 2:
            y = 1
            x += width + 1

    select_str = KEY_LAYOUT_SELECT_STR % len(layouts)
    win.addstr(Y - 2, 2, select_str, curses.A_BOLD)
    inputwin = win.subwin(1, 3, Y + 1, 5 + len(select_str))
    inputbox = curses.textpad.Textbox(inputwin)

    win.refresh()
    stdscr.refresh()

    #
    # This validation function is passed to inputbox.edit() to validate
    # individual keystrokes as the user types them. We want to limit the
    # characters the user can type. For invalid characters we return
    # Ctrl+l (refresh screen) instead of the invalid character.
    #
    def validate(ch):
        # Allow any non-visual characters (e.g. backspace)
        if not curses.ascii.isgraph(ch):
            return ch
        # Only allow digits (0-9)
        if not curses.ascii.isdigit(ch):
            return curses.ascii.ctrl('l')
        # Do not allow digits that cause the input to be invalid
        val = int(inputbox.gather().strip() + chr(ch))
        if val <= 0 or val > len(layouts):
            return curses.ascii.ctrl('l')
        return ch

    while True:
        res = inputbox.edit(validate)
        # If no input was given return without doing anything
        if len(res.strip()) == 0:
            break
        try:
            num = int(res)
            if num > 0 and num <= len(layouts):
                set_keyboard_layout(layouts[num - 1])
                break
        except ValueError:
            pass

#
# Main function.
#
def installer_main(stdscr):
    stdscr.clear()
    set_common_variables(stdscr)
    win = load_header(stdscr)

    while True:
        keypress = display_status(stdscr, win)
        if keypress == ord('9'):
            display_keyboard_layout_selection(stdscr, win)
        else:
            break

if __name__ == '__main__':
    logging.basicConfig(filename=log_file, level=logging.DEBUG)

    curses.wrapper(installer_main)
